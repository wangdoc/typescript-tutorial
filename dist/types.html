<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>TypeScript 的类型系统 - TypeScript 教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="TypeScript 的类型系统"><link rel="apple-touch-icon" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png"><link rel="manifest" href="assets/icons/manifest.json"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-end"><div class="navbar-item"><form action="https://sourcegraph.com/search" target="_blank" method="get" onsubmit='this.q.value="repo:^github.com/wangdoc/typescript-tutorial$ "+this.origin.value'><p class="control has-icons-right"><input class="input" type="text" name="origin" placeholder="搜索..."> <span class="icon is-small is-right"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#ddd" d="M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z"/></svg></span></p><input type="hidden" name="q" value=""> <input type="hidden" name="patternType" value="literal"></form></div><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/typescript-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;TypeScript 教程</a></li><li class="is-active"><a class="has-text-grey" href="types.html">类型系统</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="any.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> any 类型，unknown 类型，never 类型</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="array.html">数组 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">TypeScript 的类型系统</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><p>本章是 TypeScript 类型系统的总体介绍。</p><p>TypeScript 继承了 JavaScript 的类型，在这个基础上，定义了一套自己的类型系统。</p><h2 id="基本类型">基本类型 <a class="markdownIt-Anchor" href="#基本类型">#</a></h2><h3 id="概述">概述 <a class="markdownIt-Anchor" href="#概述">#</a></h3><p>JavaScript 语言（注意，不是 TypeScript）将值分成8种类型。</p><ul><li>boolean</li><li>string</li><li>number</li><li>bigint</li><li>symbol</li><li>object</li><li>undefined</li><li>null</li></ul><p>TypeScript 继承了 JavaScript 的类型设计，以上8种类型可以看作 TypeScript 的基本类型。</p><p>注意，上面所有类型的名称都是小写字母，首字母大写的<code>Number</code>、<code>String</code>、<code>Boolean</code>等在 JavaScript 语言中都是内置对象，而不是类型名称。</p><p>另外，undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们。</p><p>这8种基本类型是 TypeScript 类型系统的基础，复杂类型由它们组合而成。</p><p>以下是它们的简单介绍。</p><h3 id="boolean-类型">boolean 类型 <a class="markdownIt-Anchor" href="#boolean-类型">#</a></h3><p><code>boolean</code>类型只包含<code>true</code>和<code>false</code>两个布尔值。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">y</span>:<span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;
</code></pre><p>上面示例中，变量<code>x</code>和<code>y</code>就属于 boolean 类型。</p><h3 id="string-类型">string 类型 <a class="markdownIt-Anchor" href="#string-类型">#</a></h3><p><code>string</code>类型包含所有字符串。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;hello&#x27;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">y</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">`<span class="hljs-subst">${x}</span> world`</span>;
</code></pre><p>上面示例中，普通字符串和模板字符串都属于 string 类型。</p><h3 id="number-类型">number 类型 <a class="markdownIt-Anchor" href="#number-类型">#</a></h3><p><code>number</code>类型包含所有整数和浮点数。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">123</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">3.14</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">z</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">0xffff</span>;
</code></pre><p>上面示例中，整数、浮点数和非十进制数都属于 number 类型。</p><h3 id="bigint-类型">bigint 类型 <a class="markdownIt-Anchor" href="#bigint-类型">#</a></h3><p>bigint 类型包含所有的大整数。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">bigint</span> = <span class="hljs-number">123n</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">y</span>:<span class="hljs-built_in">bigint</span> = <span class="hljs-number">0xffffn</span>;
</code></pre><p>上面示例中，变量<code>x</code>和<code>y</code>就属于 bigint 类型。</p><p>bigint 与 number 类型不兼容。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">bigint</span> = <span class="hljs-number">123</span>; <span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">y</span>:<span class="hljs-built_in">bigint</span> = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>bigint</code>类型赋值为整数和小数，都会报错。</p><p>注意，bigint 类型是 ES2020 标准引入的。如果使用这个类型，TypeScript 编译的目标 JavaScript 版本不能低于 ES2020（即编译参数<code>target</code>不低于<code>es2020</code>）。</p><h3 id="symbol-类型">symbol 类型 <a class="markdownIt-Anchor" href="#symbol-类型">#</a></h3><p>symbol 类型包含所有的 Symbol 值。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">symbol</span> = <span class="hljs-title class_">Symbol</span>();
</code></pre><p>上面示例中，<code>Symbol()</code>函数的返回值就是 symbol 类型。</p><p>symbol 类型的详细介绍，参见《Symbol》一章。</p><h3 id="object-类型">object 类型 <a class="markdownIt-Anchor" href="#object-类型">#</a></h3><p>根据 JavaScript 的设计，object 类型包含了所有对象、数组和函数。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">object</span> = { <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span> };
<span class="hljs-keyword">const</span> <span class="hljs-attr">y</span>:<span class="hljs-built_in">object</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> <span class="hljs-attr">z</span>:<span class="hljs-built_in">object</span> = <span class="hljs-function">(<span class="hljs-params">n:<span class="hljs-built_in">number</span></span>) =&gt;</span> n + <span class="hljs-number">1</span>;
</code></pre><p>上面示例中，对象、数组、函数都属于 object 类型。</p><h3 id="undefined-类型null-类型">undefined 类型，null 类型 <a class="markdownIt-Anchor" href="#undefined-类型null-类型">#</a></h3><p>undefined 和 null 是两种独立类型，它们各自都只有一个值。</p><p>undefined 类型只包含一个值<code>undefined</code>，表示未定义（即还未给出定义，以后可能会有定义）。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>:<span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;
</code></pre><p>上面示例中，变量<code>x</code>就属于 undefined 类型。两个<code>undefined</code>里面，第一个是类型，第二个是值。</p><p>null 类型也只包含一个值<code>null</code>，表示为空（即此处没有值）。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>:<span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
</code></pre><p>上面示例中，变量<code>x</code>就属于 null 类型。</p><p>注意，如果没有声明类型的变量，被赋值为<code>undefined</code>或<code>null</code>，它们的类型会被推断为<code>any</code>。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> a = <span class="hljs-literal">undefined</span>;   <span class="hljs-comment">// any</span>
<span class="hljs-keyword">const</span> b = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// any</span>

<span class="hljs-keyword">let</span> c = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// any</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-literal">null</span>;      <span class="hljs-comment">// any</span>
</code></pre><p>如果希望避免这种情况，则需要打开编译选项<code>strictNullChecks</code>。</p><pre class="hljs"><code><span class="hljs-comment">// 打开编译设置 strictNullChecks</span>
<span class="hljs-keyword">let</span> a = <span class="hljs-literal">undefined</span>;   <span class="hljs-comment">// undefined</span>
<span class="hljs-keyword">const</span> b = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// undefined</span>

<span class="hljs-keyword">let</span> c = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// null</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-literal">null</span>;      <span class="hljs-comment">// null</span>
</code></pre><p>上面示例中，打开编译设置<code>strictNullChecks</code>以后，赋值为<code>undefined</code>的变量会被推断为<code>undefined</code>类型，赋值为<code>null</code>的变量会被推断为<code>null</code>类型。</p><h2 id="包装对象类型">包装对象类型 <a class="markdownIt-Anchor" href="#包装对象类型">#</a></h2><h3 id="包装对象的概念">包装对象的概念 <a class="markdownIt-Anchor" href="#包装对象的概念">#</a></h3><p>JavaScript 的8种类型之中，<code>undefined</code>和<code>null</code>其实是两个特殊值，<code>object</code>属于复合类型，剩下的五种属于原始类型（primitive value），代表最基本的、不可再分的值。</p><ul><li>boolean</li><li>string</li><li>number</li><li>bigint</li><li>symbol</li></ul><p>上面这五种原始类型的值，都有对应的包装对象（wrapper object）。所谓“包装对象”，指的是这些值在需要时，会自动产生的对象。</p><pre class="hljs"><code><span class="hljs-string">&#x27;hello&#x27;</span>.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// &#x27;e&#x27;</span>
</code></pre><p>上面示例中，字符串<code>hello</code>执行了<code>charAt()</code>方法。但是，在 JavaScript 语言中，只有对象才有方法，原始类型的值本身没有方法。这行代码之所以可以运行，就是因为在调用方法时，字符串会自动转为包装对象，<code>charAt()</code>方法其实是定义在包装对象上。</p><p>这样的设计大大方便了字符串处理，省去了将原始类型的值手动转成对象实例的麻烦。</p><p>五种包装对象之中，symbol 类型和 bigint 类型无法直接获取它们的包装对象（即<code>Symbol()</code>和<code>BigInt()</code>不能作为构造函数使用），但是剩下三种可以。</p><ul><li><code>Boolean()</code></li><li><code>String()</code></li><li><code>Number()</code></li></ul><p>以上三个构造函数，执行后可以直接获取某个原始类型值的包装对象。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);
<span class="hljs-keyword">typeof</span> s <span class="hljs-comment">// &#x27;object&#x27;</span>
s.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// &#x27;e&#x27;</span>
</code></pre><p>上面示例中，<code>s</code>就是字符串<code>hello</code>的包装对象，<code>typeof</code>运算符返回<code>object</code>，不是<code>string</code>，但是本质上它还是字符串，可以使用所有的字符串方法。</p><p>注意，<code>String()</code>只有当作构造函数使用时（即带有<code>new</code>命令调用），才会返回包装对象。如果当作普通函数使用（不带有<code>new</code>命令），返回就是一个普通字符串。其他两个构造函数<code>Number()</code>和<code>Boolean()</code>也是如此。</p><h3 id="包装对象类型与字面量类型">包装对象类型与字面量类型 <a class="markdownIt-Anchor" href="#包装对象类型与字面量类型">#</a></h3><p>由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。</p><pre class="hljs"><code><span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-comment">// 字面量</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment">// 包装对象</span>
</code></pre><p>上面示例中，第一行是字面量，第二行是包装对象，它们都是字符串。</p><p>为了区分这两种情况，TypeScript 对五种原始类型分别提供了大写和小写两种类型。</p><ul><li>Boolean 和 boolean</li><li>String 和 string</li><li>Number 和 number</li><li>BigInt 和 bigint</li><li>Symbol 和 symbol</li></ul><p>其中，大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">s1</span>:<span class="hljs-title class_">String</span> = <span class="hljs-string">&#x27;hello&#x27;</span>; <span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">s2</span>:<span class="hljs-title class_">String</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>); <span class="hljs-comment">// 正确</span>

<span class="hljs-keyword">const</span> <span class="hljs-attr">s3</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;hello&#x27;</span>; <span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">s4</span>:<span class="hljs-built_in">string</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>); <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>String</code>类型可以赋值为字符串的字面量，也可以赋值为包装对象。但是，<code>string</code>类型只能赋值为字面量，赋值为包装对象就会报错。</p><p>建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">n1</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">n2</span>:<span class="hljs-title class_">Number</span> = <span class="hljs-number">1</span>;

<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(n1) <span class="hljs-comment">// 1</span>
<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(n2) <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>Math.abs()</code>方法的参数类型被定义成小写的<code>number</code>，传入大写的<code>Number</code>类型就会报错。</p><p>上一小节说过，<code>Symbol()</code>和<code>BigInt()</code>这两个函数不能当作构造函数使用，所以没有办法直接获得 symbol 类型和 bigint 类型的包装对象，因此<code>Symbol</code>和<code>BigInt</code>这两个类型虽然存在，但是完全没有使用的理由。</p><h2 id="object-类型与-object-类型">Object 类型与 object 类型 <a class="markdownIt-Anchor" href="#object-类型与-object-类型">#</a></h2><p>TypeScript 的对象类型也有大写<code>Object</code>和小写<code>object</code>两种。</p><h3 id="object-类型-1">Object 类型 <a class="markdownIt-Anchor" href="#object-类型-1">#</a></h3><p>大写的<code>Object</code>类型代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，都是<code>Object</code>类型，这囊括了几乎所有的值。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">Object</span>;
 
obj = <span class="hljs-literal">true</span>;
obj = <span class="hljs-string">&#x27;hi&#x27;</span>;
obj = <span class="hljs-number">1</span>;
obj = { <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span> };
obj = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
obj = <span class="hljs-function">(<span class="hljs-params">a:<span class="hljs-built_in">number</span></span>) =&gt;</span> a + <span class="hljs-number">1</span>;
</code></pre><p>上面示例中，原始类型值、对象、数组、函数都是合法的<code>Object</code>类型。</p><p>事实上，除了<code>undefined</code>和<code>null</code>这两个值不能转为对象，其他任何值都可以赋值给<code>Object</code>类型。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">Object</span>;

obj = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 报错</span>
obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>undefined</code>和<code>null</code>赋值给<code>Object</code>类型，就会报错。</p><p>另外，空对象<code>{}</code>是<code>Object</code>类型的简写形式，所以使用<code>Object</code>时常常用空对象代替。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>:{};
 
obj = <span class="hljs-literal">true</span>;
obj = <span class="hljs-string">&#x27;hi&#x27;</span>;
obj = <span class="hljs-number">1</span>;
obj = { <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span> };
obj = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
obj = <span class="hljs-function">(<span class="hljs-params">a:<span class="hljs-built_in">number</span></span>) =&gt;</span> a + <span class="hljs-number">1</span>;
</code></pre><p>上面示例中，变量<code>obj</code>的类型是空对象<code>{}</code>，就代表<code>Object</code>类型。</p><p>显然，无所不包的<code>Object</code>类型既不符合直觉，也不方便使用。</p><h3 id="object-类型-2">object 类型 <a class="markdownIt-Anchor" href="#object-类型-2">#</a></h3><p>小写的<code>object</code>类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>:<span class="hljs-built_in">object</span>;
 
obj = { <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span> };
obj = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
obj = <span class="hljs-function">(<span class="hljs-params">a:<span class="hljs-built_in">number</span></span>) =&gt;</span> a + <span class="hljs-number">1</span>;
obj = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 报错</span>
obj = <span class="hljs-string">&#x27;hi&#x27;</span>; <span class="hljs-comment">// 报错</span>
obj = <span class="hljs-number">1</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>object</code>类型不包含原始类型值，只包含对象、数组和函数。</p><p>大多数时候，我们使用对象类型，只希望包含真正的对象，不希望包含原始类型。所以，建议总是使用小写类型<code>object</code>，不使用大写类型<code>Object</code>。</p><p>注意，无论是大写的<code>Object</code>类型，还是小写的<code>object</code>类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">o1</span>:<span class="hljs-title class_">Object</span> = { <span class="hljs-attr">foo</span>: <span class="hljs-number">0</span> };
<span class="hljs-keyword">const</span> <span class="hljs-attr">o2</span>:<span class="hljs-built_in">object</span> = { <span class="hljs-attr">foo</span>: <span class="hljs-number">0</span> };

o1.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 正确</span>
o1.<span class="hljs-property">foo</span> <span class="hljs-comment">// 报错</span>

o2.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 正确</span>
o2.<span class="hljs-property">foo</span> <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>toString()</code>是对象的原生方法，可以正确访问。<code>foo</code>是自定义属性，访问就会报错。如何描述对象的自定义属性，详见《对象类型》一章。</p><h2 id="undefined-和-null-的特殊性">undefined 和 null 的特殊性 <a class="markdownIt-Anchor" href="#undefined-和-null-的特殊性">#</a></h2><p><code>undefined</code>和<code>null</code>既是值，又是类型。</p><p>作为值，它们有一个特殊的地方：任何其他类型的变量都可以赋值为<code>undefined</code>或<code>null</code>。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">24</span>;

age = <span class="hljs-literal">null</span>;      <span class="hljs-comment">// 正确</span>
age = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面代码中，变量<code>age</code>的类型是<code>number</code>，但是赋值为<code>null</code>或<code>undefined</code>并不报错。</p><p>这并不是因为<code>undefined</code>和<code>null</code>包含在<code>number</code>类型里面，而是故意这样设计，任何类型的变量都可以赋值为<code>undefined</code>和<code>null</code>，以便跟 JavaScript 的行为保持一致。</p><p>JavaScript 的行为是，变量如果等于<code>undefined</code>就表示还没有赋值，如果等于<code>null</code>就表示值为空。所以，TypeScript 就允许了任何类型的变量都可以赋值为这两个值。</p><p>但是有时候，这并不是开发者想要的行为，也不利于发挥类型系统的优势。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-built_in">object</span> = <span class="hljs-literal">undefined</span>;
obj.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 编译不报错，运行就报错</span>
</code></pre><p>上面示例中，变量<code>obj</code>等于<code>undefined</code>，编译不会报错。但是，实际执行时，调用<code>obj.toString()</code>就报错了，因为<code>undefined</code>不是对象，没有这个方法。</p><p>为了避免这种情况，及早发现错误，TypeScript 提供了一个编译选项<code>strictNullChecks</code>。只要打开这个选项，<code>undefined</code>和<code>null</code>就不能赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）。</p><p>下面是 tsc 命令打开这个编译选项的例子。</p><pre class="hljs"><code><span class="hljs-comment">// tsc --strictNullChecks app.ts</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">24</span>;

age = <span class="hljs-literal">null</span>;      <span class="hljs-comment">// 报错</span>
age = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，打开<code>--strictNullChecks</code>以后，<code>number</code>类型的变量<code>age</code>就不能赋值为<code>undefined</code>和<code>null</code>。</p><p>这个选项在配置文件<code>tsconfig.json</code>的写法如下。</p><pre class="hljs"><code><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;strictNullChecks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
    <span class="hljs-comment">// ...</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre><p>打开<code>strictNullChecks</code>以后，<code>undefined</code>和<code>null</code>这两种值也不能互相赋值了。</p><pre class="hljs"><code><span class="hljs-comment">// 打开 strictNullChecks</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>:<span class="hljs-literal">undefined</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">y</span>:<span class="hljs-literal">null</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>undefined</code>类型的变量赋值为<code>null</code>，或者<code>null</code>类型的变量赋值为<code>undefind</code>，都会报错。</p><p>总之，打开<code>strictNullChecks</code>以后，<code>undefined</code>和<code>null</code>只能赋值给自身，或者<code>any</code>类型和<code>unknown</code>类型的变量。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">any</span>     = <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">y</span>:<span class="hljs-built_in">unknown</span> = <span class="hljs-literal">null</span>;
</code></pre><h2 id="值类型">值类型 <a class="markdownIt-Anchor" href="#值类型">#</a></h2><p>TypeScript 规定，单个值也是一种类型，称为“值类型”。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>:<span class="hljs-string">&#x27;hello&#x27;</span>;

x = <span class="hljs-string">&#x27;hello&#x27;</span>; <span class="hljs-comment">// 正确</span>
x = <span class="hljs-string">&#x27;world&#x27;</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，变量<code>x</code>的类型是字符串<code>hello</code>，导致它只能赋值为这个字符串，赋值为其他字符串就会报错。</p><p>TypeScript 推断类型时，遇到<code>const</code>命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。</p><pre class="hljs"><code><span class="hljs-comment">// x 的类型是 &quot;https&quot;</span>
<span class="hljs-keyword">const</span> x = <span class="hljs-string">&#x27;https&#x27;</span>;

<span class="hljs-comment">// y 的类型是 string</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">y</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;https&#x27;</span>;
</code></pre><p>上面示例中，变量<code>x</code>是<code>const</code>命令声明的，TypeScript 就会推断它的类型是值<code>https</code>，而不是<code>string</code>类型。</p><p>这样推断是合理的，因为<code>const</code>命令声明的变量，一旦声明就不能改变，相当于常量。值类型就意味着不能赋为其他值。</p><p>注意，<code>const</code>命令声明的变量，如果赋值为对象，并不会推断为值类型。</p><pre class="hljs"><code><span class="hljs-comment">// x 的类型是 { foo: number }</span>
<span class="hljs-keyword">const</span> x = { <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> };
</code></pre><p>上面示例中，变量<code>x</code>没有被推断为值类型，而是推断属性<code>foo</code>的类型是<code>number</code>。这是因为 JavaScript 里面，<code>const</code>变量赋值为对象时，属性值是可以改变的。</p><p>值类型可能会出现一些很奇怪的报错。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>:<span class="hljs-number">5</span> = <span class="hljs-number">4</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，等号左侧的类型是数值<code>5</code>，等号右侧<code>4 + 1</code>的类型，TypeScript 推测为<code>number</code>。由于<code>5</code>是<code>number</code>的子类型，<code>number</code>是<code>5</code>的父类型，父类型不能赋值给子类型，所以报错了（详见本章后文）。</p><p>但是，反过来是可以的，子类型可以赋值给父类型。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>:<span class="hljs-number">5</span> = <span class="hljs-number">5</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">4</span> + <span class="hljs-number">1</span>;

x = y; <span class="hljs-comment">// 报错</span>
y = x; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，变量<code>x</code>属于子类型，变量<code>y</code>属于父类型。<code>y</code>不能赋值为子类型<code>x</code>，但是反过来是可以的。</p><p>如果一定要让子类型可以赋值为父类型的值，就要用到类型断言（详见《类型断言》一章）。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>:<span class="hljs-number">5</span> = (<span class="hljs-number">4</span> + <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-number">5</span>; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，在<code>4 + 1</code>后面加上<code>as 5</code>，就是告诉编译器，可以把<code>4 + 1</code>的类型视为值类型<code>5</code>，这样就不会报错了。</p><p>只包含单个值的值类型，用处不大。实际开发中，往往将多个值结合，作为联合类型使用。</p><h2 id="联合类型">联合类型 <a class="markdownIt-Anchor" href="#联合类型">#</a></h2><p>联合类型（union types）指的是多个类型组成的一个新类型，使用符号<code>|</code>表示。</p><p>联合类型<code>A|B</code>表示，任何一个类型只要属于<code>A</code>或<code>B</code>，就属于联合类型<code>A|B</code>。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>;

x = <span class="hljs-number">123</span>; <span class="hljs-comment">// 正确</span>
x = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，变量<code>x</code>就是联合类型<code>string|number</code>，表示它的值既可以是字符串，也可以是数值。</p><p>联合类型可以与值类型相结合，表示一个变量的值有若干种可能。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">setting</span>:<span class="hljs-literal">true</span>|<span class="hljs-literal">false</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">gender</span>:<span class="hljs-string">&#x27;male&#x27;</span>|<span class="hljs-string">&#x27;female&#x27;</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">rainbowColor</span>:<span class="hljs-string">&#x27;赤&#x27;</span>|<span class="hljs-string">&#x27;橙&#x27;</span>|<span class="hljs-string">&#x27;黄&#x27;</span>|<span class="hljs-string">&#x27;绿&#x27;</span>|<span class="hljs-string">&#x27;青&#x27;</span>|<span class="hljs-string">&#x27;蓝&#x27;</span>|<span class="hljs-string">&#x27;紫&#x27;</span>;
</code></pre><p>上面的示例都是由值类型组成的联合类型，非常清晰地表达了变量的取值范围。其中，<code>true|false</code>其实就是布尔类型<code>boolean</code>。</p><p>前面提到，打开编译选项<code>strictNullChecks</code>后，其他类型的变量不能赋值为<code>undefined</code>或<code>null</code>。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>|<span class="hljs-literal">null</span>;

name = <span class="hljs-string">&#x27;John&#x27;</span>;
name = <span class="hljs-literal">null</span>;
</code></pre><p>上面示例中，变量<code>name</code>的值可以是字符串，也可以是<code>null</code>。</p><p>联合类型的第一个成员前面，也可以加上竖杠<code>|</code>，这样便于多行书写。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>:
  | <span class="hljs-string">&#x27;one&#x27;</span>
  | <span class="hljs-string">&#x27;two&#x27;</span>
  | <span class="hljs-string">&#x27;three&#x27;</span>
  | <span class="hljs-string">&#x27;four&#x27;</span>;
</code></pre><p>上面示例中，联合类型的第一个成员<code>one</code>前面，加上了竖杠。</p><p>如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">printId</span>(<span class="hljs-params">
  id:<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>
</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id.<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// 报错</span>
}
</code></pre><p>上面示例中，参数变量<code>id</code>可能是数值，也可能是字符串，这时直接对这个变量调用<code>toUpperCase()</code>方法会报错，因为这个方法只存在于字符串，不存在于数值。</p><p>解决方法就是对参数<code>id</code>做一下类型缩小，确定它的类型以后再进行处理。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">printId</span>(<span class="hljs-params">
  id:<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>
</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> id === <span class="hljs-string">&#x27;string&#x27;</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id.<span class="hljs-title function_">toUpperCase</span>());
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id);
  }
}
</code></pre><p>上面示例中，函数体内部会判断一下变量<code>id</code>的类型，如果是字符串，就对其执行<code>toUpperCase()</code>方法。</p><p>“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。实际上，联合类型本身可以看成是一种“类型放大”（type widening），处理时就需要“类型缩小”（type narrowing）。</p><p>下面是“类型缩小”的另一个例子。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPort</span>(<span class="hljs-params">
  scheme: <span class="hljs-string">&#x27;http&#x27;</span>|<span class="hljs-string">&#x27;https&#x27;</span>
</span>) {
  <span class="hljs-keyword">switch</span> (scheme) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;http&#x27;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-number">80</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;https&#x27;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-number">443</span>;
  }
}
</code></pre><p>上面示例中，函数体内部对参数变量<code>scheme</code>进行类型缩小，根据不同的值类型，返回不同的结果。</p><h2 id="交叉类型">交叉类型 <a class="markdownIt-Anchor" href="#交叉类型">#</a></h2><p>交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号<code>&amp;</code>表示。</p><p>交叉类型<code>A&amp;B</code>表示，任何一个类型必须同时属于<code>A</code>和<code>B</code>，才属于交叉类型<code>A&amp;B</code>，即交叉类型同时满足<code>A</code>和<code>B</code>的特征。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>&amp;<span class="hljs-built_in">string</span>;
</code></pre><p>上面示例中，变量<code>x</code>同时是数值和字符串，这当然是不可能的，所以 TypeScript 会认为<code>x</code>的类型实际是<code>never</code>。</p><p>交叉类型的主要用途是表示对象的合成。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>:
  { <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span> } &amp;
  { <span class="hljs-attr">bar</span>: <span class="hljs-built_in">string</span> };

obj = {
  <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;hello&#x27;</span>,
  <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;world&#x27;</span>
};
</code></pre><p>上面示例中，变量<code>obj</code>同时具有属性<code>foo</code>和属性<code>bar</code>。</p><p>交叉类型常常用来为对象类型添加新属性。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> A = { <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span> };

<span class="hljs-keyword">type</span> B = A &amp; { <span class="hljs-attr">bar</span>: <span class="hljs-built_in">number</span> };
</code></pre><p>上面示例中，类型<code>B</code>是一个交叉类型，用来在<code>A</code>的基础上增加了属性<code>bar</code>。</p><h2 id="type-命令">type 命令 <a class="markdownIt-Anchor" href="#type-命令">#</a></h2><p><code>type</code>命令用来定义一个类型的别名。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Age</span> = <span class="hljs-built_in">number</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>:<span class="hljs-title class_">Age</span> = <span class="hljs-number">55</span>;
</code></pre><p>上面示例中，<code>type</code>命令为<code>number</code>类型定义了一个别名<code>Age</code>。这样就能像使用<code>number</code>一样，使用<code>Age</code>作为类型。</p><p>别名可以让类型的名字变得更有意义，也能增加代码的可读性，还可以使复杂类型用起来更方便，便于以后修改变量的类型。</p><p>别名不允许重名。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Color</span> = <span class="hljs-string">&#x27;blue&#x27;</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，同一个别名<code>Color</code>声明了两次，就报错了。</p><p>别名的作用域是块级作用域。这意味着，代码块内部定义的别名，影响不到外部。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;

<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &lt; <span class="hljs-number">0.5</span>) {
  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Color</span> = <span class="hljs-string">&#x27;blue&#x27;</span>;
}
</code></pre><p>上面示例中，<code>if</code>代码块内部的类型别名<code>Color</code>，跟外部的<code>Color</code>是不一样的。</p><p>别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即别名允许嵌套。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">World</span> = <span class="hljs-string">&quot;world&quot;</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Greeting</span> = <span class="hljs-string">`hello <span class="hljs-subst">${World}</span>`</span>;
</code></pre><p>上面示例中，别名<code>Greeting</code>使用了模板字符串，读取另一个别名<code>World</code>。</p><p><code>type</code>命令属于类型相关的代码，编译成 JavaScript 的时候，会被全部删除。</p><h2 id="typeof-运算符">typeof 运算符 <a class="markdownIt-Anchor" href="#typeof-运算符">#</a></h2><p>JavaScript 语言中，typeof 运算符是一个一元运算符，返回一个字符串，代表操作数的类型。</p><pre class="hljs"><code><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;foo&#x27;</span>; <span class="hljs-comment">// &#x27;string&#x27;</span>
</code></pre><p>上面示例中，<code>typeof</code>运算符返回字符串<code>foo</code>的类型是<code>string</code>。</p><p>注意，这时 typeof 的操作数是一个值。</p><p>JavaScript 里面，<code>typeof</code>运算符只可能返回八种结果，而且都是字符串。</p><pre class="hljs"><code><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &quot;undefined&quot;</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// &quot;boolean&quot;</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-number">1337</span>; <span class="hljs-comment">// &quot;number&quot;</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;foo&quot;</span>; <span class="hljs-comment">// &quot;string&quot;</span>
<span class="hljs-keyword">typeof</span> {}; <span class="hljs-comment">// &quot;object&quot;</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">parseInt</span>; <span class="hljs-comment">// &quot;function&quot;</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(); <span class="hljs-comment">// &quot;symbol&quot;</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-number">127n</span> <span class="hljs-comment">// &quot;bigint&quot;</span>
</code></pre><p>上面示例是<code>typeof</code>运算符在 JavaScript 语言里面，可能返回的八种结果。</p><p>TypeScript 将<code>typeof</code>运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> a = { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span> };

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-keyword">typeof</span> a;   <span class="hljs-comment">// { x: number }</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-keyword">typeof</span> a.<span class="hljs-property">x</span>; <span class="hljs-comment">// number</span>
</code></pre><p>上面示例中，<code>typeof a</code>表示返回变量<code>a</code>的 TypeScript 类型（<code>{ x: number }</code>）。同理，<code>typeof a.x</code>返回的是属性<code>x</code>的类型（<code>number</code>）。</p><p>这种用法的<code>typeof</code>返回的是 TypeScript 类型，所以只能用在类型运算之中（即跟类型相关的代码之中），不能用在值运算。</p><p>也就是说，同一段代码可能存在两种<code>typeof</code>运算符，一种用在值相关的 JavaScript 代码部分，另一种用在类型相关的 TypeScript 代码部分。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>:<span class="hljs-keyword">typeof</span> a;

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;number&#x27;</span>) {
  b = a;
}
</code></pre><p>上面示例中，用到了两个<code>typeof</code>，第一个是类型运算，第二个是值运算。它们是不一样的，不要混淆。</p><p>JavaScript 的 typeof 遵守 JavaScript 规则，TypeScript 的 typeof 遵守 TypeScript 规则。它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。</p><p>上例的代码编译结果如下。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> b;
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;number&#x27;</span>) {
    b = a;
}
</code></pre><p>上面示例中，只保留了原始代码的第二个 typeof，删除了第一个 typeof。</p><p>由于编译时不会进行 JavaScript 的值运算，所以TypeScript 规定，typeof 的参数只能是标识符，不能是需要运算的表达式。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> T = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Date</span>(); <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例会报错，原因是 typeof 的参数不能是一个值的运算式，而<code>Date()</code>需要运算才知道结果。</p><p>另外，<code>typeof</code>命令的参数不能是类型。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Age</span> = <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">MyAge</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Age</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>Age</code>是一个类型别名，用作<code>typeof</code>命令的参数就会报错。</p><p>typeof 是一个很重要的 TypeScript 运算符，有些场合不知道某个变量<code>foo</code>的类型，这时使用<code>typeof foo</code>就可以获得它的类型。</p><h2 id="块级类型声明">块级类型声明 <a class="markdownIt-Anchor" href="#块级类型声明">#</a></h2><p>TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。</p><pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">type</span> T = <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">let</span> <span class="hljs-attr">v</span>:T = <span class="hljs-number">5</span>;
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">type</span> T = <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">let</span> <span class="hljs-attr">v</span>:T = <span class="hljs-string">&#x27;hello&#x27;</span>;
}
</code></pre><p>上面示例中，存在两个代码块，其中分别有一个类型<code>T</code>的声明。这两个声明都只在自己的代码块内部有效，在代码块外部无效。</p><h2 id="类型的兼容">类型的兼容 <a class="markdownIt-Anchor" href="#类型的兼容">#</a></h2><p>TypeScript 的类型存在兼容关系，某些类可以兼容其他类。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> T = <span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>:T = a;
</code></pre><p>上面示例中，变量<code>a</code>和<code>b</code>的类型是不一样的，但是变量<code>a</code>赋值给变量<code>b</code>并不会报错。这时，我们就认为，变量<code>b</code>兼容变量<code>a</code>。</p><p>TypeScript<br>为这种情况定义了一个专门术语。如果类型<code>A</code>的值可以赋值给类型<code>B</code>，那么类型<code>A</code>就称为类型<code>B</code>的子类型（subtype）。在上例中，类型<code>number</code>就是类型<code>number|string</code>的子类型。</p><p>TypeScript 的一个规则是，凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;hi&#x27;</span> = <span class="hljs-string">&#x27;hi&#x27;</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;hello&#x27;</span>;

b = a; <span class="hljs-comment">// 正确</span>
a = b; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>hi</code>是<code>string</code>的子类型，<code>string</code>是<code>hi</code>的父类型。所以，变量<code>a</code>可以赋值给变量<code>b</code>，但是反过来就会报错。</p><p>之所以有这样的规则，是因为子类型继承了父类型的所有特征，所以可以用在父类型的场合。但是，子类型还可能有一些父类型没有的特征，所以父类型不能用在子类型的场合。</p></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="any.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> any 类型，unknown 类型，never 类型</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="array.html">数组 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> TypeScript 教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="intro.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">简介</span></a></li><li><a href="basic.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">基本用法</span></a></li><li><a href="any.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">any 类型，unknown 类型，never 类型</span></a></li><li><a href="types.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型系统</span></a></li><li><a href="array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数组</span></a></li></ul></aside></div></nav><nav class="panel panel-info"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/typescript-tutorial/master/docs/types.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/typescript-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/typescript-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><div id="disqus_thread"></div></div></div></div></section><footer class="footer"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com</p></div></div></footer><script>var LOPPO={current_path:"types.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">基本类型</a>\n<ul>\n<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>\n<li><a href="#boolean-%E7%B1%BB%E5%9E%8B">boolean 类型</a></li>\n<li><a href="#string-%E7%B1%BB%E5%9E%8B">string 类型</a></li>\n<li><a href="#number-%E7%B1%BB%E5%9E%8B">number 类型</a></li>\n<li><a href="#bigint-%E7%B1%BB%E5%9E%8B">bigint 类型</a></li>\n<li><a href="#symbol-%E7%B1%BB%E5%9E%8B">symbol 类型</a></li>\n<li><a href="#object-%E7%B1%BB%E5%9E%8B">object 类型</a></li>\n<li><a href="#undefined-%E7%B1%BB%E5%9E%8Bnull-%E7%B1%BB%E5%9E%8B">undefined 类型，null 类型</a></li>\n</ul>\n</li>\n<li><a href="#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">包装对象类型</a>\n<ul>\n<li><a href="#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5">包装对象的概念</a></li>\n<li><a href="#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B">包装对象类型与字面量类型</a></li>\n</ul>\n</li>\n<li><a href="#object-%E7%B1%BB%E5%9E%8B%E4%B8%8E-object-%E7%B1%BB%E5%9E%8B">Object 类型与 object 类型</a>\n<ul>\n<li><a href="#object-%E7%B1%BB%E5%9E%8B-1">Object 类型</a></li>\n<li><a href="#object-%E7%B1%BB%E5%9E%8B-2">object 类型</a></li>\n</ul>\n</li>\n<li><a href="#undefined-%E5%92%8C-null-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">undefined 和 null 的特殊性</a></li>\n<li><a href="#%E5%80%BC%E7%B1%BB%E5%9E%8B">值类型</a></li>\n<li><a href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B">联合类型</a></li>\n<li><a href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B">交叉类型</a></li>\n<li><a href="#type-%E5%91%BD%E4%BB%A4">type 命令</a></li>\n<li><a href="#typeof-%E8%BF%90%E7%AE%97%E7%AC%A6">typeof 运算符</a></li>\n<li><a href="#%E5%9D%97%E7%BA%A7%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E">块级类型声明</a></li>\n<li><a href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9">类型的兼容</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script>var disqus_config=function(){var t=window.location,e=t.protocol+"//"+t.host+(t.port?":"+t.port:"")+t.pathname;this.page.url=e,this.page.identifier=t.pathname};!function(){var t=document,e=t.createElement("script");e.src="https://wangdoc-typescript.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><!--script src="assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《TypeScript 的类型系统》，出自网道（WangDoc.com）的《TypeScript 教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>